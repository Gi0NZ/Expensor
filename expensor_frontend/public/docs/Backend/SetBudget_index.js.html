<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: SetBudget/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: SetBudget/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { connectDB } = require("../db");
const sql = require("mssql");
const { parseCookies } = require("../utils/cookieHelper");
const jwt = require("jsonwebtoken");

/**
 * Azure Function per configurare o aggiornare il budget mensile dell'utente.
 *
 * **Logica di Business (Upsert &amp; Reset):**
 * 1. **Identificazione:** L'utente viene identificato tramite il token JWT nel cookie `auth_token`.
 * 2. **Gestione Dati (MERGE):** Utilizza lo statement SQL `MERGE` per gestire in modo atomico due scenari:
 * - **Inserimento:** Se l'utente non ha un budget, crea una nuova riga.
 * - **Aggiornamento:** Se il budget esiste, aggiorna il valore `monthly_limit`.
 * 3. **Reset Notifiche:** In caso di aggiornamento (UPDATE), imposta forzatamente `last_email_sent_month` a `NULL`.
 * *Scopo:* Se l'utente modifica il proprio budget (es. lo alza), il sistema deve dimenticare di aver già inviato un'email di allerta questo mese, permettendo l'invio di nuove notifiche se il nuovo limite viene superato.
 *
 * @module Budget
 * @param {Object} context - Il contesto di esecuzione di Azure Function.
 * @param {Object} req - L'oggetto richiesta HTTP.
 * @param {Object} req.body - Il payload della richiesta.
 * @param {number} req.body.monthly_limit - Il nuovo tetto massimo di spesa mensile desiderato.
 *
 * @returns {Promise&lt;void>} Imposta `context.res` con uno dei seguenti stati:
 * - **200 OK**: Budget salvato o aggiornato correttamente.
 * - **500 Internal Server Error**: Errore generico (include errore di autenticazione o errore SQL in questa implementazione).
 */
module.exports = async function (context, req) {
  try {
    const cookies = parseCookies(req);
    const token = cookies["auth_token"];
    if (!token) throw new Error("No token");
    const decoded = jwt.decode(token);
    const userId = decoded.oid;

    const { monthly_limit } = req.body;

    const pool = await connectDB();

    await pool
      .request()
      .input("userId", sql.NVarChar, userId)
      .input("limit", sql.Decimal(10, 2), monthly_limit).query(`
        MERGE user_budgets AS target
        USING (SELECT @userId AS user_id) AS source
        ON (target.user_id = source.user_id)
        WHEN MATCHED THEN
            UPDATE SET monthly_limit = @limit, last_email_sent_month = NULL
        WHEN NOT MATCHED THEN
            INSERT (user_id, monthly_limit) VALUES (@userId, @limit);
      `);

    context.res = {
      status: 200,

      body: { message: "Budget salvato!" },
    };
  } catch (err) {
    context.res = {
      status: 500,

      body: { error: err.message },
    };
  }
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Budget.html">Budget</a></li><li><a href="module-Expenses.html">Expenses</a></li><li><a href="module-GroupExpenses.html">GroupExpenses</a></li><li><a href="module-GroupManagement.html">GroupManagement</a></li><li><a href="module-GroupMembers.html">GroupMembers</a></li><li><a href="module-User.html">User</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Tue Jan 20 2026 11:54:42 GMT+0100 (Ora standard dell’Europa centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
